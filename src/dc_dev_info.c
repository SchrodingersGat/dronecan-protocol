// dc_dev_info.c was generated by ProtoGen version 2.3.b

/*
 * This program source code file is part of DroneCAN protocol specification
 *
 * Website: www.dronecan.org
 * GitHub: www.github.com/dronecan
 *
 * Copyright (C) 2017 Currawong Engineering Pty Ltd, see AUTHORS.txt for contributors.
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the GNU General Public License
 * as published by the Free Software Foundation; either version 2
 * of the License, or (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, you may find one here:
 * http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 * or you may search the http://www.gnu.org website for the version 2 license,
 * or you may write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA
 */

#include "dc_dev_info.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a DC_Sys_UID_t structure into a byte array
 *
 * Unique Identifier for device
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeDC_Sys_UID_t(uint8_t* data, int* bytecount, const DC_Sys_UID_t* user)
{
    int byteindex = *bytecount;

    // Vendor ID
    uint16ToBeBytes((uint16_t)user->vid, data, &byteindex);

    // Product ID
    uint16ToBeBytes((uint16_t)user->pid, data, &byteindex);

    // Device serial number
    uint24ToBeBytes((uint32_t)user->serial, data, &byteindex);

    *bytecount = byteindex;

}// encodeDC_Sys_UID_t

/*!
 * \brief Decode a DC_Sys_UID_t structure from a byte array
 *
 * Unique Identifier for device
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeDC_Sys_UID_t(const uint8_t* data, int* bytecount, DC_Sys_UID_t* user)
{
    int byteindex = *bytecount;

    // Vendor ID
    user->vid = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Product ID
    user->pid = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Device serial number
    user->serial = (uint32_t)uint24FromBeBytes(data, &byteindex);

    *bytecount = byteindex;

    return 1;

}// decodeDC_Sys_UID_t

/*!
 * \brief Encode a DC_Sys_DevFwVersion_t structure into a byte array
 *
 * Device firmware version information
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeDC_Sys_DevFwVersion_t(uint8_t* data, int* bytecount, const DC_Sys_DevFwVersion_t* user)
{
    int byteindex = *bytecount;

    // Major release number
    uint8ToBytes((uint8_t)user->major, data, &byteindex);

    // Minor release number
    uint8ToBytes((uint8_t)user->minor, data, &byteindex);

    // Sub release number
    uint8ToBytes((uint8_t)user->sub, data, &byteindex);

    *bytecount = byteindex;

}// encodeDC_Sys_DevFwVersion_t

/*!
 * \brief Decode a DC_Sys_DevFwVersion_t structure from a byte array
 *
 * Device firmware version information
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeDC_Sys_DevFwVersion_t(const uint8_t* data, int* bytecount, DC_Sys_DevFwVersion_t* user)
{
    int byteindex = *bytecount;

    // Major release number
    user->major = (uint8_t)uint8FromBytes(data, &byteindex);

    // Minor release number
    user->minor = (uint8_t)uint8FromBytes(data, &byteindex);

    // Sub release number
    user->sub = (uint8_t)uint8FromBytes(data, &byteindex);

    *bytecount = byteindex;

    return 1;

}// decodeDC_Sys_DevFwVersion_t

/*!
 * \brief Encode a DC_Sys_DevFwDate_t structure into a byte array
 *
 * Device firmware release date information
 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeDC_Sys_DevFwDate_t(uint8_t* data, int* bytecount, const DC_Sys_DevFwDate_t* user)
{
    int byteindex = *bytecount;

    // Year of release
    uint16ToBeBytes((uint16_t)user->year, data, &byteindex);

    // Month of release
    uint8ToBytes((uint8_t)user->month, data, &byteindex);

    // Day of release
    uint8ToBytes((uint8_t)user->day, data, &byteindex);

    *bytecount = byteindex;

}// encodeDC_Sys_DevFwDate_t

/*!
 * \brief Decode a DC_Sys_DevFwDate_t structure from a byte array
 *
 * Device firmware release date information
 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeDC_Sys_DevFwDate_t(const uint8_t* data, int* bytecount, DC_Sys_DevFwDate_t* user)
{
    int byteindex = *bytecount;

    // Year of release
    user->year = (uint16_t)uint16FromBeBytes(data, &byteindex);

    // Month of release
    user->month = (uint8_t)uint8FromBytes(data, &byteindex);

    // Day of release
    user->day = (uint8_t)uint8FromBytes(data, &byteindex);

    *bytecount = byteindex;

    return 1;

}// decodeDC_Sys_DevFwDate_t

// end of dc_dev_info.c
