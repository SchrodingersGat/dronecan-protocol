// dc_pkt_block.c was generated by ProtoGen version 2.2.d

#include "dc_pkt_block.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a DC_Block_BlockEndpointInfo_t structure into a byte array
 *

 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeDC_Block_BlockEndpointInfo_t(uint8_t* data, int* bytecount, const DC_Block_BlockEndpointInfo_t* user)
{
    int byteindex = *bytecount;

    // Total data size (bytes)
    uint32ToBeBytes((uint32_t)user->datSize, data, &byteindex);

    // Single block size (bytes)
    uint16ToBeBytes((uint16_t)user->blockSize, data, &byteindex);

    *bytecount = byteindex;

}// encodeDC_Block_BlockEndpointInfo_t

/*!
 * \brief Decode a DC_Block_BlockEndpointInfo_t structure from a byte array
 *

 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeDC_Block_BlockEndpointInfo_t(const uint8_t* data, int* bytecount, DC_Block_BlockEndpointInfo_t* user)
{
    int byteindex = *bytecount;

    // Total data size (bytes)
    user->datSize = (uint32_t)uint32FromBeBytes(data, &byteindex);

    // Single block size (bytes)
    user->blockSize = (uint16_t)uint16FromBeBytes(data, &byteindex);

    *bytecount = byteindex;

    return 1;

}// decodeDC_Block_BlockEndpointInfo_t

/*!
 * \brief Create the DC_Block_BlockDataEndpointInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeDC_Block_BlockDataEndpointInfoPacketStructure(DC_Packet_t* pkt, const DC_Block_BlockDataEndpointInfo_t* user)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)user->endpoint, data, &byteindex);

    uint32ToBeBytes((uint32_t)user->size, data, &byteindex);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_BlockDataEndpointInfoPacketID());
}

/*!
 * \brief Decode the DC_Block_BlockDataEndpointInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_BlockDataEndpointInfoPacketStructure(const DC_Packet_t* pkt, DC_Block_BlockDataEndpointInfo_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_BlockDataEndpointInfoPacketID())
        return 0;

    // Verify the packet size
    numBytes = getDC_BlockPacketSize(pkt);
    if(numBytes < getDC_Block_BlockDataEndpointInfoMinDataLength())
        return 0;

    // The raw data from the packet
    data = getDC_BlockPacketDataConst(pkt);

    user->endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    user->size = (uint32_t)uint32FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the DC_Block_BlockEndpointInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param endpoint is 
 * \param info is 
 */
void encodeDC_Block_BlockEndpointInfoPacket(DC_Packet_t* pkt, uint8_t endpoint, const DC_Block_BlockEndpointInfo_t* info)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)endpoint, data, &byteindex);

    encodeDC_Block_BlockEndpointInfo_t(data, &byteindex, info);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_BlockEndpointInfoPacketID());
}

/*!
 * \brief Decode the DC_Block_BlockEndpointInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param endpoint receives 
 * \param info receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_BlockEndpointInfoPacket(const DC_Packet_t* pkt, uint8_t* endpoint, DC_Block_BlockEndpointInfo_t* info)
{
    int byteindex = 0;
    const uint8_t* data = getDC_BlockPacketDataConst(pkt);
    int numBytes = getDC_BlockPacketSize(pkt);

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_BlockEndpointInfoPacketID())
        return 0;

    if(numBytes < getDC_Block_BlockEndpointInfoMinDataLength())
        return 0;

    *endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    if(decodeDC_Block_BlockEndpointInfo_t(data, &byteindex, info) == 0)
        return 0;

    return 1;
}

/*!
 * \brief Create the DC_Block_GetBlockEndpointInfo packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param endpoint is 
 */
void encodeDC_Block_GetBlockEndpointInfoPacket(DC_Packet_t* pkt, uint8_t endpoint)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    uint8ToBytes((uint8_t)endpoint, data, &byteindex);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_GetBlockEndpointInfoPacketID());
}

/*!
 * \brief Decode the DC_Block_GetBlockEndpointInfo packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param endpoint receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_GetBlockEndpointInfoPacket(const DC_Packet_t* pkt, uint8_t* endpoint)
{
    int byteindex = 0;
    const uint8_t* data = getDC_BlockPacketDataConst(pkt);
    int numBytes = getDC_BlockPacketSize(pkt);

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_GetBlockEndpointInfoPacketID())
        return 0;

    if(numBytes < getDC_Block_GetBlockEndpointInfoMinDataLength())
        return 0;

    *endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the DC_Block_BlockAddress packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeDC_Block_BlockAddressPacketStructure(DC_Packet_t* pkt, const DC_Block_BlockAddress_t* user)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    // Block starting address
    uint32ToBeBytes((uint32_t)user->address, data, &byteindex);

    // Block data endpoint
    uint8ToBytes((uint8_t)user->endpoint, data, &byteindex);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_BlockAddressPacketID());
}

/*!
 * \brief Decode the DC_Block_BlockAddress packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_BlockAddressPacketStructure(const DC_Packet_t* pkt, DC_Block_BlockAddress_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_BlockAddressPacketID())
        return 0;

    // Verify the packet size
    numBytes = getDC_BlockPacketSize(pkt);
    if(numBytes < getDC_Block_BlockAddressMinDataLength())
        return 0;

    // The raw data from the packet
    data = getDC_BlockPacketDataConst(pkt);

    // Block starting address
    user->address = (uint32_t)uint32FromBeBytes(data, &byteindex);

    // Block data endpoint
    user->endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the DC_Block_BlockAddress packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param address is Block starting address
 * \param endpoint is Block data endpoint
 */
void encodeDC_Block_BlockAddressPacket(DC_Packet_t* pkt, uint32_t address, uint8_t endpoint)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    // Block starting address
    uint32ToBeBytes((uint32_t)address, data, &byteindex);

    // Block data endpoint
    uint8ToBytes((uint8_t)endpoint, data, &byteindex);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_BlockAddressPacketID());
}

/*!
 * \brief Decode the DC_Block_BlockAddress packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param address receives Block starting address
 * \param endpoint receives Block data endpoint
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_BlockAddressPacket(const DC_Packet_t* pkt, uint32_t* address, uint8_t* endpoint)
{
    int byteindex = 0;
    const uint8_t* data = getDC_BlockPacketDataConst(pkt);
    int numBytes = getDC_BlockPacketSize(pkt);

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_BlockAddressPacketID())
        return 0;

    if(numBytes < getDC_Block_BlockAddressMinDataLength())
        return 0;

    // Block starting address
    *address = (uint32_t)uint32FromBeBytes(data, &byteindex);

    // Block data endpoint
    *endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the DC_Block_BlockChecksum packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeDC_Block_BlockChecksumPacketStructure(DC_Packet_t* pkt, const DC_Block_BlockChecksum_t* user)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    // Block starting address
    uint32ToBeBytes((uint32_t)user->address, data, &byteindex);

    // Block data endpoint
    uint8ToBytes((uint8_t)user->endpoint, data, &byteindex);

    // Block checksum
    uint16ToBeBytes((uint16_t)user->checksum, data, &byteindex);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_BlockChecksumPacketID());
}

/*!
 * \brief Decode the DC_Block_BlockChecksum packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_BlockChecksumPacketStructure(const DC_Packet_t* pkt, DC_Block_BlockChecksum_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_BlockChecksumPacketID())
        return 0;

    // Verify the packet size
    numBytes = getDC_BlockPacketSize(pkt);
    if(numBytes < getDC_Block_BlockChecksumMinDataLength())
        return 0;

    // The raw data from the packet
    data = getDC_BlockPacketDataConst(pkt);

    // Block starting address
    user->address = (uint32_t)uint32FromBeBytes(data, &byteindex);

    // Block data endpoint
    user->endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    // Block checksum
    user->checksum = (uint16_t)uint16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the DC_Block_BlockChecksum packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param address is Block starting address
 * \param endpoint is Block data endpoint
 * \param checksum is Block checksum
 */
void encodeDC_Block_BlockChecksumPacket(DC_Packet_t* pkt, uint32_t address, uint8_t endpoint, uint16_t checksum)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    // Block starting address
    uint32ToBeBytes((uint32_t)address, data, &byteindex);

    // Block data endpoint
    uint8ToBytes((uint8_t)endpoint, data, &byteindex);

    // Block checksum
    uint16ToBeBytes((uint16_t)checksum, data, &byteindex);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_BlockChecksumPacketID());
}

/*!
 * \brief Decode the DC_Block_BlockChecksum packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param address receives Block starting address
 * \param endpoint receives Block data endpoint
 * \param checksum receives Block checksum
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_BlockChecksumPacket(const DC_Packet_t* pkt, uint32_t* address, uint8_t* endpoint, uint16_t* checksum)
{
    int byteindex = 0;
    const uint8_t* data = getDC_BlockPacketDataConst(pkt);
    int numBytes = getDC_BlockPacketSize(pkt);

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_BlockChecksumPacketID())
        return 0;

    if(numBytes < getDC_Block_BlockChecksumMinDataLength())
        return 0;

    // Block starting address
    *address = (uint32_t)uint32FromBeBytes(data, &byteindex);

    // Block data endpoint
    *endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    // Block checksum
    *checksum = (uint16_t)uint16FromBeBytes(data, &byteindex);

    return 1;
}

/*!
 * \brief Create the DC_Block_StartBlockTransfer packet
 *

 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeDC_Block_StartBlockTransferPacketStructure(DC_Packet_t* pkt, const DC_Block_StartBlockTransfer_t* user)
{
    uint8_t* data = getDC_BlockPacketData(pkt);
    int byteindex = 0;

    // Transfer ID
    uint8ToBytes((uint8_t)user->id, data, &byteindex);

    // Transfer endpoint
    uint8ToBytes((uint8_t)user->endpoint, data, &byteindex);

    // Transfer address
    uint32ToBeBytes((uint32_t)user->address, data, &byteindex);

    // Transfer size (bytes)
    uint16ToBeBytes((uint16_t)user->size, data, &byteindex);

    // complete the process of creating the packet
    finishDC_BlockPacket(pkt, byteindex, getDC_Block_StartBlockTransferPacketID());
}

/*!
 * \brief Decode the DC_Block_StartBlockTransfer packet
 *

 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Block_StartBlockTransferPacketStructure(const DC_Packet_t* pkt, DC_Block_StartBlockTransfer_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getDC_BlockPacketID(pkt) != getDC_Block_StartBlockTransferPacketID())
        return 0;

    // Verify the packet size
    numBytes = getDC_BlockPacketSize(pkt);
    if(numBytes < getDC_Block_StartBlockTransferMinDataLength())
        return 0;

    // The raw data from the packet
    data = getDC_BlockPacketDataConst(pkt);

    // Transfer ID
    user->id = (uint8_t)uint8FromBytes(data, &byteindex);

    // Transfer endpoint
    user->endpoint = (uint8_t)uint8FromBytes(data, &byteindex);

    // Transfer address
    user->address = (uint32_t)uint32FromBeBytes(data, &byteindex);

    // Transfer size (bytes)
    user->size = (uint16_t)uint16FromBeBytes(data, &byteindex);

    return 1;
}
// end of dc_pkt_block.c
