// DroneCAN_SystemPackets.c was generated by ProtoGen version 2.18.c

/**

Copyright (c) 2020 DroneCAN

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

**/

#include "DroneCAN_SystemPackets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_DeviceStatusPacketStructure(void* _pg_pkt)
{
    int _pg_byteindex = 0;

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_DeviceStatusPacketID());
}

/*!
 * \brief Decode the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID is wrong, else 1
 */
int decodeDroneCAN_DeviceStatusPacketStructure(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_DeviceStatusPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_DeviceStatusPacket(void* _pg_pkt)
{
    // Zero length packet, no data encoded
    finishDroneCANPacket(_pg_pkt, 0, getDroneCAN_DeviceStatusPacketID());
}

/*!
 * \brief Decode the DroneCAN_DeviceStatus packet
 *
 * Device status information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_DeviceStatusPacket(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_DeviceStatusPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_UniqueIdPacketStructure(void* _pg_pkt, const DroneCAN_UniqueId_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Vendor ID
    uint16ToBeBytes(_pg_user->vid, _pg_data, &_pg_byteindex);

    // Product ID
    uint16ToBeBytes(_pg_user->pid, _pg_data, &_pg_byteindex);

    // Device serial number
    uint24ToBeBytes((uint32_t)(_pg_user->seiral), _pg_data, &_pg_byteindex);

    // CAN node address
    uint8ToBytes(_pg_user->address, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_UniqueIdPacketID());
}

/*!
 * \brief Decode the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_UniqueIdPacketStructure(const void* _pg_pkt, DroneCAN_UniqueId_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_UniqueIdPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_UniqueIdMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    // Vendor ID
    _pg_user->vid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Product ID
    _pg_user->pid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Device serial number
    _pg_user->seiral = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // CAN node address
    _pg_user->address = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet which will be created by this function
 * \param vid is Vendor ID
 * \param pid is Product ID
 * \param seiral is Device serial number
 * \param address is CAN node address
 */
void encodeDroneCAN_UniqueIdPacket(void* _pg_pkt, uint16_t vid, uint16_t pid, uint32_t seiral, uint8_t address)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Vendor ID
    uint16ToBeBytes(vid, _pg_data, &_pg_byteindex);

    // Product ID
    uint16ToBeBytes(pid, _pg_data, &_pg_byteindex);

    // Device serial number
    uint24ToBeBytes((uint32_t)(seiral), _pg_data, &_pg_byteindex);

    // CAN node address
    uint8ToBytes(address, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_UniqueIdPacketID());
}

/*!
 * \brief Decode the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet being decoded by this function
 * \param vid receives Vendor ID
 * \param pid receives Product ID
 * \param seiral receives Device serial number
 * \param address receives CAN node address
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_UniqueIdPacket(const void* _pg_pkt, uint16_t* vid, uint16_t* pid, uint32_t* seiral, uint8_t* address)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_UniqueIdPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_UniqueIdMinDataLength())
        return 0;

    // Vendor ID
    *vid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Product ID
    *pid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Device serial number
    *seiral = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // CAN node address
    *address = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_FirwareVersionPacketStructure(void* _pg_pkt, const DroneCAN_FirwareVersion_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(_pg_user->versionMajor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionMinor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionSub, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->checksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirwareVersionPacketID());
}

/*!
 * \brief Decode the DroneCAN_FirwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirwareVersionPacketStructure(const void* _pg_pkt, DroneCAN_FirwareVersion_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirwareVersionPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_FirwareVersionMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    _pg_user->versionMajor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionMinor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionSub = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->checksum = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param versionMajor is 
 * \param versionMinor is 
 * \param versionSub is 
 * \param checksum is 
 */
void encodeDroneCAN_FirwareVersionPacket(void* _pg_pkt, uint8_t versionMajor, uint8_t versionMinor, uint8_t versionSub, uint32_t checksum)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(versionMajor, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionMinor, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionSub, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(checksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirwareVersionPacketID());
}

/*!
 * \brief Decode the DroneCAN_FirwareVersion packet
 *
 * Firmware version information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param versionMajor receives 
 * \param versionMinor receives 
 * \param versionSub receives 
 * \param checksum receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirwareVersionPacket(const void* _pg_pkt, uint8_t* versionMajor, uint8_t* versionMinor, uint8_t* versionSub, uint32_t* checksum)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirwareVersionPacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_FirwareVersionMinDataLength())
        return 0;

    *versionMajor = uint8FromBytes(_pg_data, &_pg_byteindex);

    *versionMinor = uint8FromBytes(_pg_data, &_pg_byteindex);

    *versionSub = uint8FromBytes(_pg_data, &_pg_byteindex);

    *checksum = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_FirmwareDatePacketStructure(void* _pg_pkt, const DroneCAN_FirmwareDate_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(_pg_user->versionYear, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionMonth, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionDay, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareDatePacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareDatePacketStructure(const void* _pg_pkt, DroneCAN_FirmwareDate_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareDatePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_FirmwareDateMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    _pg_user->versionYear = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionMonth = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionDay = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet which will be created by this function
 * \param versionYear is 
 * \param versionMonth is 
 * \param versionDay is 
 */
void encodeDroneCAN_FirmwareDatePacket(void* _pg_pkt, uint16_t versionYear, uint8_t versionMonth, uint8_t versionDay)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(versionYear, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionMonth, _pg_data, &_pg_byteindex);

    uint8ToBytes(versionDay, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareDatePacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareDate packet
 *
 * Firmware date information
 * \param _pg_pkt points to the packet being decoded by this function
 * \param versionYear receives 
 * \param versionMonth receives 
 * \param versionDay receives 
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareDatePacket(const void* _pg_pkt, uint16_t* versionYear, uint8_t* versionMonth, uint8_t* versionDay)
{
    int _pg_byteindex = 0;
    const uint8_t* _pg_data = getDroneCANPacketDataConst(_pg_pkt);
    int _pg_numbytes = getDroneCANPacketSize(_pg_pkt);

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareDatePacketID())
        return 0;

    if(_pg_numbytes < getDroneCAN_FirmwareDateMinDataLength())
        return 0;

    *versionYear = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    *versionMonth = uint8FromBytes(_pg_data, &_pg_byteindex);

    *versionDay = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_HardwareInfoPacketStructure(void* _pg_pkt)
{
    int _pg_byteindex = 0;

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_HardwareInfoPacketID());
}

/*!
 * \brief Decode the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID is wrong, else 1
 */
int decodeDroneCAN_HardwareInfoPacketStructure(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_HardwareInfoPacketID())
        return 0;
    else
        return 1;
}

/*!
 * \brief Create the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_HardwareInfoPacket(void* _pg_pkt)
{
    // Zero length packet, no data encoded
    finishDroneCANPacket(_pg_pkt, 0, getDroneCAN_HardwareInfoPacketID());
}

/*!
 * \brief Decode the DroneCAN_HardwareInfo packet
 *
 * Hardware information
 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_HardwareInfoPacket(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_HardwareInfoPacketID())
        return 0;
    else
        return 1;
}
// end of DroneCAN_SystemPackets.c
