// DroneCAN_SystemPackets.c was generated by ProtoGen version 2.18.c

/**

Copyright (c) 2020 DroneCAN

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

**/

#include "DroneCAN_SystemPackets.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Create the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_UniqueIdPacketStructure(void* _pg_pkt, const DroneCAN_UniqueId_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    // Vendor ID
    uint16ToBeBytes(_pg_user->vid, _pg_data, &_pg_byteindex);

    // Product ID
    uint16ToBeBytes(_pg_user->pid, _pg_data, &_pg_byteindex);

    // Device serial number
    uint24ToBeBytes((uint32_t)(_pg_user->seiral), _pg_data, &_pg_byteindex);

    // CAN node address
    uint8ToBytes(_pg_user->address, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_UniqueIdPacketID());
}

/*!
 * \brief Decode the DroneCAN_UniqueId packet
 *
 * Unique identifier for DroneCAN device
 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_UniqueIdPacketStructure(const void* _pg_pkt, DroneCAN_UniqueId_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_UniqueIdPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_UniqueIdMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    // Vendor ID
    _pg_user->vid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Product ID
    _pg_user->pid = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    // Device serial number
    _pg_user->seiral = (uint32_t)uint24FromBeBytes(_pg_data, &_pg_byteindex);

    // CAN node address
    _pg_user->address = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirwareVersion packet
 *

 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_FirwareVersionPacketStructure(void* _pg_pkt, const DroneCAN_FirwareVersion_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint8ToBytes(_pg_user->versionMajor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionMinor, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionSub, _pg_data, &_pg_byteindex);

    uint32ToBeBytes(_pg_user->checksum, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirwareVersionPacketID());
}

/*!
 * \brief Decode the DroneCAN_FirwareVersion packet
 *

 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirwareVersionPacketStructure(const void* _pg_pkt, DroneCAN_FirwareVersion_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirwareVersionPacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_FirwareVersionMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    _pg_user->versionMajor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionMinor = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionSub = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->checksum = uint32FromBeBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_FirmwareDate packet
 *

 * \param _pg_pkt points to the packet which will be created by this function
 * \param _pg_user points to the user data that will be encoded in _pg_pkt
 */
void encodeDroneCAN_FirmwareDatePacketStructure(void* _pg_pkt, const DroneCAN_FirmwareDate_t* _pg_user)
{
    uint8_t* _pg_data = getDroneCANPacketData(_pg_pkt);
    int _pg_byteindex = 0;

    uint16ToBeBytes(_pg_user->versionYear, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionMonth, _pg_data, &_pg_byteindex);

    uint8ToBytes(_pg_user->versionDay, _pg_data, &_pg_byteindex);

    // complete the process of creating the packet
    finishDroneCANPacket(_pg_pkt, _pg_byteindex, getDroneCAN_FirmwareDatePacketID());
}

/*!
 * \brief Decode the DroneCAN_FirmwareDate packet
 *

 * \param _pg_pkt points to the packet being decoded by this function
 * \param _pg_user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_FirmwareDatePacketStructure(const void* _pg_pkt, DroneCAN_FirmwareDate_t* _pg_user)
{
    int _pg_numbytes;
    int _pg_byteindex = 0;
    const uint8_t* _pg_data;

    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_FirmwareDatePacketID())
        return 0;

    // Verify the packet size
    _pg_numbytes = getDroneCANPacketSize(_pg_pkt);
    if(_pg_numbytes < getDroneCAN_FirmwareDateMinDataLength())
        return 0;

    // The raw data from the packet
    _pg_data = getDroneCANPacketDataConst(_pg_pkt);

    _pg_user->versionYear = uint16FromBeBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionMonth = uint8FromBytes(_pg_data, &_pg_byteindex);

    _pg_user->versionDay = uint8FromBytes(_pg_data, &_pg_byteindex);

    return 1;
}

/*!
 * \brief Create the DroneCAN_HardwareInfo packet
 *

 * \param _pg_pkt points to the packet which will be created by this function
 */
void encodeDroneCAN_HardwareInfoPacket(void* _pg_pkt)
{
    // Zero length packet, no data encoded
    finishDroneCANPacket(_pg_pkt, 0, getDroneCAN_HardwareInfoPacketID());
}

/*!
 * \brief Decode the DroneCAN_HardwareInfo packet
 *

 * \param _pg_pkt points to the packet being decoded by this function
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDroneCAN_HardwareInfoPacket(const void* _pg_pkt)
{
    // Verify the packet identifier
    if(getDroneCANPacketID(_pg_pkt) != getDroneCAN_HardwareInfoPacketID())
        return 0;
    else
        return 1;
}
// end of DroneCAN_SystemPackets.c
