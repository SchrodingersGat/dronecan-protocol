// dc_pkt_telem.c was generated by ProtoGen version 2.2.d

#include "dc_pkt_telem.h"
#include "fielddecode.h"
#include "fieldencode.h"
#include "scaleddecode.h"
#include "scaledencode.h"

/*!
 * \brief Encode a DC_Telemetry_DeviceStatusField_t structure into a byte array
 *

 * \param data points to the byte array to add encoded data to
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of encoded bytes.
 * \param user is the data to encode in the byte array
 */
void encodeDC_Telemetry_DeviceStatusField_t(uint8_t* data, int* bytecount, const DC_Telemetry_DeviceStatusField_t* user)
{
    int byteindex = *bytecount;

    // Device mode
    data[byteindex] = (uint8_t)user->mode << 4;

    // Device warning
    data[byteindex] |= (uint8_t)user->warning << 3;

    // Device error
    data[byteindex] |= (uint8_t)user->error << 2;

    // Device critical
    data[byteindex] |= (uint8_t)user->critical << 1;

    // Device fatal
    data[byteindex] |= (uint8_t)user->fatal;
    byteindex += 1; // close bit field

    *bytecount = byteindex;

}// encodeDC_Telemetry_DeviceStatusField_t

/*!
 * \brief Decode a DC_Telemetry_DeviceStatusField_t structure from a byte array
 *

 * \param data points to the byte array to decoded data from
 * \param bytecount points to the starting location in the byte array, and will be incremented by the number of bytes decoded
 * \param user is the data to decode from the byte array
 * \return 1 if the data are decoded, else 0. If 0 is returned bytecount will not be updated.
 */
int decodeDC_Telemetry_DeviceStatusField_t(const uint8_t* data, int* bytecount, DC_Telemetry_DeviceStatusField_t* user)
{
    int byteindex = *bytecount;

    // Device mode
    user->mode = (data[byteindex] >> 4);

    // Device warning
    user->warning = ((data[byteindex] >> 3) & 0x1);

    // Device error
    user->error = ((data[byteindex] >> 2) & 0x1);

    // Device critical
    user->critical = ((data[byteindex] >> 1) & 0x1);

    // Device fatal
    user->fatal = ((data[byteindex]) & 0x1);
    byteindex += 1; // close bit field

    *bytecount = byteindex;

    return 1;

}// decodeDC_Telemetry_DeviceStatusField_t

/*!
 * \brief Create the DC_Telemetry_DeviceStatus packet
 *
 * Device status
 * \param pkt points to the packet which will be created by this function
 * \param user points to the user data that will be encoded in pkt
 */
void encodeDC_Telemetry_DeviceStatusPacketStructure(DC_Packet_t* pkt, const DC_Telemetry_DeviceStatus_t* user)
{
    uint8_t* data = getDC_TelemetryPacketData(pkt);
    int byteindex = 0;

    // Device status information
    encodeDC_Telemetry_DeviceStatusField_t(data, &byteindex, &user->status);

    // Device uptime (s)
    uint32ToBeBytes((uint32_t)user->uptime, data, &byteindex);

    // complete the process of creating the packet
    finishDC_TelemetryPacket(pkt, byteindex, getDC_Telemetry_DeviceStatusPacketID());
}

/*!
 * \brief Decode the DC_Telemetry_DeviceStatus packet
 *
 * Device status
 * \param pkt points to the packet being decoded by this function
 * \param user receives the data decoded from the packet
 * \return 0 is returned if the packet ID or size is wrong, else 1
 */
int decodeDC_Telemetry_DeviceStatusPacketStructure(const DC_Packet_t* pkt, DC_Telemetry_DeviceStatus_t* user)
{
    int numBytes;
    int byteindex = 0;
    const uint8_t* data;

    // Verify the packet identifier
    if(getDC_TelemetryPacketID(pkt) != getDC_Telemetry_DeviceStatusPacketID())
        return 0;

    // Verify the packet size
    numBytes = getDC_TelemetryPacketSize(pkt);
    if(numBytes < getDC_Telemetry_DeviceStatusMinDataLength())
        return 0;

    // The raw data from the packet
    data = getDC_TelemetryPacketDataConst(pkt);

    // Device status information
    if(decodeDC_Telemetry_DeviceStatusField_t(data, &byteindex, &user->status) == 0)
        return 0;

    // Device uptime (s)
    user->uptime = (uint32_t)uint32FromBeBytes(data, &byteindex);

    return 1;
}
// end of dc_pkt_telem.c
